![Uploaded Image](https://gamzatech-bucket.s3.ap-northeast-2.amazonaws.com/post-images/112/9398e403-2ca4-4cc7-8996-98ea6f729115_image.png)
지금 나는 데브코스를 수강중이다, 어제 특강으로 클린코드에 대해 배웠다, 먼저 나는 이 특강을 듣기전에
클린코드 책에 대해 한번 읽은적이 있는데 다시 상기도 되고 책에서 이해가 되지 않았던 부분에 대해서
어느정도 다시 이해가 된 거 같아서 좋았다. 그래서 다시 상기를 시키는 방향으로 글을 적어보려고 한다. 

### 1. 의도를 분명히 밝혀라
내가 전에 책을 읽었을때도, 이번 특강에서도의 말은 메서드, 변수, 클래스명등
정확한 네임이 있어야 한다는거다. 애매한 이름은 항상 좋지않다.

```
void calc(int a, int b)

int calculateInvoiceTotal(int quantity, int unitPrice)
```

이런 코드이다. 나는 내가 작성해서 단편적으로 기억 하겠지만, 이런 상황을 기억해야한다.

>1. 내 코드는 내가 보는게 아닌, 남이 훨씬 많이 본다. 
2. 내가 개떡같이 작성을 해서 기억한다고 한들 시간이 조금이라도 지나면 잊혀진다.

이것이다. 나중에는 분명 까먹는게 사람이니 처음부터 잘 짜면 함수를 다시 뒤져볼 필요도없다.

### 2. 조건을 캡슐화 하자
조건의 의도를 분명하게 밝히는 함수로 표현을 해야한다. 

```
// 나쁜 예

if ((employee. flags & HOURLY_FLAG) && (employee.age > 65)) 

// 좋은 예

if (employee.isEligibleForFullBenefits())

```

### 3. 함수는 하나의 역할만 수행해야한다
한 함수가 이것을 지키지 않는 코드를 많이 볼 수 있을것이다.
이번 조건은 아마 클린코드에서 함수를 작게 많이 쪼개자 라는 말과도 연관이있다.
어떤 함수를 본다면, 로그인에 너무 많은 역할을 하고있고, 책임을 지고있는경우가 있고
이런것이 아니더라도 많은 책임을 지는 코드는 좋지않다. 

```
public Money calculatePay(Employee e) throws InvalidEmployeeType {
  switch(e.type) {
    case COMMISSIONED:
      return calculateCommisionedPay(e);
    case HOURLY:
      return calculateHourlyPay(e);
    case SALARIED:
      return calculateSalariedPay(e);
    default:
      throw new InvalidEmployeeType(e.type);
  }
  
}
```

1. 이 코드의 문제는 함수가 너무 길다.
2. SRP를 위반한다.
3. OCP를 위반한다.
4. 유사한 함수가 계속 나올 가능성이 있다.
5. 한가지만 수행하지않는다.

이것을 해결하기 위해서는 추상클래스를 만들어 하위클래스에서 선언하는것이 좋다. 
하위 객체를 생성하기 위한 switch문은 불가피하다. 그래도 문제점을 상당수 해결 할 수 있을것이다.

```
public abstract class Employee {
    public abstract int calculatePay();
    public abstract void deliverPay();
}

public class EmployeeFactory {

    public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType {
        switch (r.type) {
            case COMMISSIONED:
                return new CommissionedEmployee(r);
            case HOURLY:
                return HourlyEmployee(r);
            case SALARIED:
                return SalariedEmployee(r);
            default:
                throw new InvalidEmployeeType(r.type);
        }
    }

}
```

### 4. 명령과 조회를 분리해라
함수는 뭔가를 수행하거나, 조회하거나 하나의 역할만 해야한다. 두개의 역할을 동시에 하면
이상한 함수가 나오게 된다. 예를 들어 Key값이 존재하는지 확인하고 존재하지않으면 데이터를
추가하여 성공하면 true 실패하면 false를 반환하는 함수가 있다면
```
public boolean set(String attribute, String value);

if(set("username", "MangKyu")) {

}
```

위의 코드를 접한 사람은 이 함수가 key가 존재하는 경우 overwrite하는지 혹은 존재하지않을 경우에만 업데이트
하는지 등 자세한 내용을 알수 없을것이다. 이유는 위의 함수가 명령과 조회를 한번에 처리하기 때문이다. 
함수를 분리해서 다음과같이 처리 해줘야한다.
```
public boolean attributeExists(String attribute);
public boolean setAttribute(String attribute, String value);

if(attributeExists("username")) {
    setAttribute("username", "MangKyu");
}
```

### 5. 오류 코드보다는 예외를 활용하자
오류코드를 반환하면 분기가 일어나게 되고 또 중첩되기가 좋다.
```
public Status deletePage(Page page) {
    if(deletePage(page) == E_OK) {
        if(registry.deleteReference(page.name) == E_OK) {
            if(configKeys.deleteKey(page.name.makeKey()) == E_OK) {
                log.info("page deleted");
                return E_OK;
            } else {
                log.error("config key not deleted");
            }
        } else {
            log.error("reference not deleted");
        }
    } else {
        log.error("page not deleted");
    }
    return E_ERROR;
}
```

이것을 해결하기 위해 함수에서 예외처리를 시키면 더 간단하게 작성이 가능하다.
```
public void deletePage(Page page) {
    try {
        deletePage(page);
        registry.deleteReference(page.name);
        configKeys.deleteKey(page.name.makeKey());
    } catch (Exception e) {
        log.error(e.getMessage());
    }
}
```

이 try - catch문도 쪼갤 수 있다.

```
public void deletePage(Page page) {
    try {
        deletePageAndAllReferences(page);
    } catch (Exception e) {
        log.error(e.getMessage());
    }
}

public void deletePageAndAllReferences(Page page) throws Exception {
    deletePage(page);
    registry.deleteReference(page.name);
    configKeys.deleteKey(page.name.makeKey());
}
```

### 6. 여러 예외가 발생하는 경우 Wrapper 클래스로 감싸자
외부 라이브러리를 이용하면 다양한 예외 클래스를 마주하게 된다. 이런 예외들을 처리하려면 많이 버거워진다.
```
ACMEPort port = new ACMEPort(12);
try {
    port.open();
} catch (DeviceResponseException e) {
    log.error(e.getMessage());
} catch (ATM1212UnlockedException e) {
    log.error(e.getMessage());
} catch (GMXError e) {
    log.error(e.getMessage());
} finally {
    ...
}
```

이런 상황에서 Wrapper 클래스를 이용해 감싸면 효과적으로 처리가 가능하다.
```
LocalPort port = new LocalPort(12);
try {
    port.open();
} catch (PortDeviceFailure e) {
    log.error(e.getMessage());
} finally {
    ...
}

public class LocalPort {

    private ACMEPort innerPort;

    public LocalPort(int portNumber) {
        this.innerPort = new ACMEPort(portNumber);
    }

    public void open() {
        try {
            innerPort.open();
        } catch (DeviceResponseException e) {
            throw new PortDeviceFailure(e);
        } catch (ATM1212UnlockedException e) {
            throw new PortDeviceFailure(e);
        } catch (GMXError e) {
            throw new PortDeviceFailure(e);
        }
    }

}
```

### 7. 테스트코드를 작성하자
TDD는 원 코드를 작성하기전에 작성하는 테스트이다. 유연성과 유지보수성 재사용성을 제공받는다. 

1. 실패하는 단위테스트를 작성할 때까지 실제코드를 작성하지마라.
2. 컴파일은 실패하지않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.
3. 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.

실제 코드를 변경한다는 것은 버그가 발생할 수 있음을 내포하고있다. 테스트 코드가 있다면 변경된 코드를 검증함으로
해결이 가능하다. 실제 코드가 변경되면 테스트코드도 변경해주어야하고, 가독성이 필요하다. 테스트를 작성하는 방법중 유의할건

1. 1개의 테스트 함수에 대해 assert를 최소화해라
2. 1개의 테스트 함수는 1가지 개념만을 테스트해라

이렇게이다.

> 나는 테스트코드 책을 조금 많이 봤던 거 같은데, 어떤 책에는 assert문을 최소화하고 1개만 써라 라는것을 본적이 있었던거 같은데
어떤 강의나 다른 책은 상관이 없고 여러개를 적용해도 된다라고 봤던 기억이 있다. 클린코드의 원칙인건 맞지만 이런 말을 한것을보면
불가피한 상황이 있을 경우나 다른 상황이 있던 것이라고 생각한다. 원칙을 지키면 좋지만 꼭 원칙에 의존하다가 다른것들을 버리지 말길 바란다.

그리고 어제 나는 특강을 들으며 강사님에게 물어봤다. 그분은 네카쿠배라중 한곳을 다니시는 강사님이셨는데, 나의 질문은 이렇다.

코드를 작성할때 현업에서도 TDD를 거의 작성합니까?, 작성하지 않는 코드도 있나요? , 팀마다 테스트 커버리지는 어떻게 맞추고 테스트 합니까? 였다.

내가 이 질문을 한 이유는 
1. 내가 전에 클린코드 책을 봤을때도 TDD가 중요하다고 본적이 있어서
2. TDD에 관한 책을 좀 봤고, 내가 작성해봤을때 나름대로 설계에 대해 생각이 들게 했는데 이것이 정말 현업에서도, 쓰이는지
3. 정말 궁금해서

이렇게이다. 질문을 약간 이상하게 한 거 같기도한데 여튼 대답을 들었다.

>일단 강사님 본인은 TDD는 하지않는다고 했다. 대신 테스트코드는 무조건 다 짠다고 말씀하셨고
다른 팀들의 경우는 TDD를 꼭 하거나 그런분들도 있고 팀의 차이나 개인의 차이라고 했다.
테스트 커버리지에 대해서는 엄청 까다롭게 하지는 않는데 이것도 팀by팀 이라고 엄청 중요시 여기는 곳도 있다고 했다.
분석은 SonarQube를 사용한다고 들었다, 예전에 k8s를 같이 공부할때 한번 써본적이 있는데 이후에 한번도 쓰지않아
잊혀졌었는데 이런데에 쓰이는거구나 했다. 그래서 파서 공부를 해보려고 생각중이다.

### 8. 클래스의 응집도
객체 지향을 공부하다 보면 높은 응집도와 낮은 결합도를 듣는다. 
응집도란 클래스와 메소드와 변수가 얼마나 의존하여 사용되는지 의미한다.
Stack클래스는 size()를 제외한 모든 함수에서 두 인스턴스 변수를 사용해서 응집도가 매우 높다.
```
public class Stack {
    
    private int topOfStack=0;
    private List<Integer> elements = new LinkedList<>();
    
    public int size() {
        return topOfStack;
    }
    
    public void push(int element) {
        topOfStack++;
        elements.add(element);
    }
    
    public int pop() throws PoppedWhenEmpty{
        if(topOfStack == 0) {
            throw new PoppedWhenEmpty();
        }
        int element = elements.get(--topOfStack);
        elements.remove(topOfStack);
        return element;
    }
    
}

```

### 9. 변경하기 쉬운 클래스
요구사항은 수시로 변하기 때문에 쉬운 클래스를 만드는 것이 중요하다. 변경하기 쉬운 클래스는 
기본적으로 단일책임 원칙을 지켜야한다. 구현체보다 추상체에 의존하여야한다.
```
abstract public class SQL {
    public SQL(String table, Column[] columns)
    abstract public String generate();
}

public class CreateSQL extends SQL {
    public CreateSQL(String table, Column[] columns)
    @Override public String generate()
}

public class SelectSQL extends SQL {
    public SelectSQL(String table, Column[] columns)
    @Override public String generate()
}
```

### 10. 설계 품질을 높여주기 위한 4가지
1. 모든 테스트를 실행하자, 테스트가 쉬운 코드를 작성하면 SRP를 준수하고 낮은 결합도의 설계를 얻을 수 있다.
2. 중복을 제거하자, 좋은 시스템을 만들기 위해 몇줄이라도 중복을 최소해라.
3. 프로그래머의 의도를 표현하자, 이름을 좀 잘짓자 정확한 남이 알아볼만한,
4. 클래스와 메소드 수를 줄여라, 클래스 메소드를 적게 유지하고 시스템 크기를 작게 유지하자.

### 11. 디미터 법칙
디미터의 법칙은 어떤 모듈이 호출하는 객체의 속사정을 몰라야한다는것이다.객체는 자료를 숨기고 함수를 공개한다.
만약 자료를 그대로 노출하면 내부 구조가 드러나 결합도가 높아진다.

```
final String outputDir = FileManager.getInstance().getOptions().getModule().getAbsolutePath();

```

위의 코드는 이렇게 나눈다.

```
Options options = ctxt.getOptions();
File scratchDir = opts.getScratchDir();
final String outputDir = scratchDir.getAbsolutePath();

```

만약 위의 클래스 자료구조라면 괜찮다. 하지만 객체라면 내부구조를 숨겨야해서, 한번 더 수정해야한다.
내부 코드를 살펴보니 위의 코드로 절대 경로를 얻는 이유는 임시 파일을 생성하기 위해서다. 그렇기에 
위의 코드를 다음과 같이 임시 파일을 생성하라는 메시지를 보내는것이 좋다.
```
BufferedOutputStream bos = ctxt.createScartchFileStream(classFileName);

```

데이터가 아닌 객체를 참고할때 여러번의 . 을 사용하는 경우에 객체에게 메시지를 보내도록 변경하자, 
.은 최대한 한번만 사용해서 최소화 하는것이 좋다.

## 마치며
나는 클린 코드를 읽었을때 나의 코드의 개선점이나 어떻게 코드를 짜야하는지를 어느정도 기본적으로 알게 될 수 있었다.
코드는 테스트코드도 중요하며 클린코드를 보며 지켜야 할 규칙도 많다. 너무나도 좋은 책이고 한번쯤은 읽어보면 좋을거 같다.
처음 시작하는 사람이나 코드가 누가 봐도 엉망인 사람이 처음 읽으면 어느정도 습득도 가능하고 유용할 것이다.
>그렇지만 너무 클린코드를 맹신하고 무조건 지켜야한다는 생각을 가지면 안된다는거다. 원칙은 분명히 좋지만, 너무 과하면 어떤것도 
안좋다는듯이 이것도 그렇다, 서치만 해도 연관 검색어에 클린코드 비판이 나온다. 
ex) 클린코드 원칙만 너무 지키다가 품질이 좋지 않아졌다.
ex) 단일 책임 원칙을 지키다가 API가 더 보기 좋지 않아졌다.
ex) 함수 쪼개기를 적용했더니 가독성에 전혀 도움이 되지않았다.

이런 이야기들이 많다. 클린코드는 분명 좋은 책이지만 너무 맹신하고 지키려고 들지말자, 분명히 좋은 책이지만
사람마다, 상황마다, 회사마다 다 다를것이다. 
클린코드는 다른 자료처럼, 적절할 때 사용해야하는 도구일 뿐이다. 가끔 너무 클린한 코드는 맥락을 잃을 위험이 있다고도 한다.

나도 맞다고 생각한다. 분명 좋은 책이지만, 책하나를 읽고 이게 정답이야! 라고 적용하면서 그동안 배운것을 까먹지를 않기를 바란다.
유연하게 더 좋은 코드를 짜기 위해 노력해야한다고 생각한다.